/**
 * PostgreSQL configuration optimizer
 * Handles database settings that require restart and configuration changes
 */

import { Pool } from 'pg';
import { errorLogger } from './error-logger';
import fs from 'fs/promises';
import path from 'path';

interface PostgreSQLConfig {
  parameter: string;
  recommendedValue: string;
  currentValue?: string;
  requiresRestart: boolean;
  description: string;
}

class PostgreSQLOptimizer {
  constructor(private pool: Pool) {}

  async analyzeConfiguration(): Promise<PostgreSQLConfig[]> {
    const configs: PostgreSQLConfig[] = [
      {
        parameter: 'shared_buffers',
        recommendedValue: '256MB',
        requiresRestart: true,
        description: 'Amount of memory allocated for caching data'
      },
      {
        parameter: 'effective_cache_size',
        recommendedValue: '1GB',
        requiresRestart: false,
        description: 'Estimate of memory available for disk caching'
      },
      {
        parameter: 'maintenance_work_mem',
        recommendedValue: '256MB',
        requiresRestart: false,
        description: 'Memory for maintenance operations like VACUUM, CREATE INDEX'
      },
      {
        parameter: 'checkpoint_completion_target',
        recommendedValue: '0.9',
        requiresRestart: false,
        description: 'Time to complete checkpoint as fraction of checkpoint_timeout'
      },
      {
        parameter: 'wal_buffers',
        recommendedValue: '16MB',
        requiresRestart: true,
        description: 'Amount of memory for WAL buffers'
      },
      {
        parameter: 'default_statistics_target',
        recommendedValue: '100',
        requiresRestart: false,
        description: 'Default statistics target for table columns'
      },
      {
        parameter: 'random_page_cost',
        recommendedValue: '1.1',
        requiresRestart: false,
        description: 'Cost of non-sequential page fetch (SSD optimization)'
      }
    ];

    // Get current values
    for (const config of configs) {
      try {
        const result = await this.pool.query(`SHOW ${config.parameter}`);
        config.currentValue = result.rows[0]?.[config.parameter];
      } catch (error: any) {
        await errorLogger.logError({
          level: 'warning',
          source: 'database',
          message: `Failed to get current value for ${config.parameter}: ${error.message}`
        });
      }
    }

    return configs;
  }

  async applyNonRestartSettings(): Promise<{ applied: string[]; failed: string[] }> {
    const applied: string[] = [];
    const failed: string[] = [];

    const nonRestartSettings = [
      { parameter: 'effective_cache_size', value: '1GB' },
      { parameter: 'maintenance_work_mem', value: '256MB' },
      { parameter: 'checkpoint_completion_target', value: '0.9' },
      { parameter: 'default_statistics_target', value: '100' },
      { parameter: 'random_page_cost', value: '1.1' }
    ];

    for (const setting of nonRestartSettings) {
      try {
        await this.pool.query(`SET ${setting.parameter} = '${setting.value}'`);
        applied.push(`${setting.parameter} = ${setting.value}`);
        
        await errorLogger.logError({
          level: 'info',
          source: 'database',
          message: `Applied PostgreSQL setting: ${setting.parameter} = ${setting.value}`
        });
      } catch (error: any) {
        failed.push(`${setting.parameter}: ${error.message}`);
        
        await errorLogger.logError({
          level: 'warning',
          source: 'database',
          message: `Failed to apply setting ${setting.parameter}: ${error.message}`
        });
      }
    }

    return { applied, failed };
  }

  async generateConfigurationFile(): Promise<string> {
    const configContent = `
# PostgreSQL Configuration Optimization
# Generated by MDM/PIM Platform Monitoring System

# Memory Settings
shared_buffers = 256MB                  # 25% of RAM for small systems
effective_cache_size = 1GB              # Estimate of OS + DB cache
maintenance_work_mem = 256MB            # Memory for maintenance operations
work_mem = 16MB                         # Memory for query operations

# Checkpoint Settings
checkpoint_completion_target = 0.9      # Spread checkpoints over time
checkpoint_timeout = 10min              # Checkpoint frequency

# WAL Settings
wal_buffers = 16MB                      # WAL buffer size
wal_level = replica                     # Enable replication
max_wal_size = 1GB                      # Maximum WAL size

# Query Planner Settings
default_statistics_target = 100         # Statistics target
random_page_cost = 1.1                  # SSD optimization
effective_io_concurrency = 200          # Concurrent I/O operations

# Connection Settings
max_connections = 100                   # Maximum connections
shared_preload_libraries = 'pg_stat_statements'  # Enable query statistics

# Logging Settings (for monitoring)
log_statement = 'mod'                   # Log modifications
log_min_duration_statement = 1000       # Log slow queries (1 second)
log_checkpoints = on                    # Log checkpoint activity
log_connections = on                    # Log connections
log_disconnections = on                 # Log disconnections
log_lock_waits = on                     # Log lock waits

# Auto-vacuum Settings
autovacuum = on                         # Enable auto-vacuum
autovacuum_max_workers = 3              # Auto-vacuum workers
autovacuum_naptime = 1min               # Auto-vacuum frequency
`;

    try {
      const configPath = path.join(process.cwd(), 'postgresql-optimization.conf');
      await fs.writeFile(configPath, configContent.trim());
      
      await errorLogger.logError({
        level: 'info',
        source: 'database',
        message: `PostgreSQL configuration file generated: ${configPath}`
      });

      return configPath;
    } catch (error: any) {
      await errorLogger.logError({
        level: 'error',
        source: 'database',
        message: `Failed to generate PostgreSQL configuration: ${error.message}`
      });
      throw error;
    }
  }

  async getOptimizationRecommendations(): Promise<string[]> {
    const recommendations: string[] = [];

    try {
      // Check current settings and provide recommendations
      const configs = await this.analyzeConfiguration();
      
      configs.forEach(config => {
        if (config.currentValue !== config.recommendedValue) {
          if (config.requiresRestart) {
            recommendations.push(
              `Restart required: Set ${config.parameter} = ${config.recommendedValue} (currently: ${config.currentValue})`
            );
          } else {
            recommendations.push(
              `Runtime change: Set ${config.parameter} = ${config.recommendedValue} (currently: ${config.currentValue})`
            );
          }
        }
      });

      // Check for pg_stat_statements extension
      try {
        await this.pool.query("SELECT * FROM pg_stat_statements LIMIT 1");
      } catch (error) {
        recommendations.push("Enable pg_stat_statements extension for query performance monitoring");
      }

      // Check for missing indexes
      const indexCheck = await this.pool.query(`
        SELECT schemaname, relname, attname, n_distinct, correlation
        FROM pg_stats
        WHERE schemaname = 'public' 
        AND n_distinct > 100 
        AND correlation < 0.1
        LIMIT 5
      `);

      if (indexCheck.rows.length > 0) {
        recommendations.push("Consider adding indexes for high-cardinality columns with low correlation");
      }

    } catch (error: any) {
      recommendations.push("Enable detailed PostgreSQL monitoring for comprehensive optimization analysis");
    }

    return recommendations;
  }

  async optimizeConnectionPool(): Promise<{ status: string; recommendations: string[] }> {
    const recommendations: string[] = [];
    
    try {
      const poolStats = {
        totalCount: this.pool.totalCount,
        idleCount: this.pool.idleCount,
        waitingCount: this.pool.waitingCount
      };

      await errorLogger.logError({
        level: 'info',
        source: 'database',
        message: 'Connection pool analysis completed',
        context: poolStats
      });

      if (poolStats.waitingCount > 0) {
        recommendations.push("Increase connection pool size - clients are waiting for connections");
      }

      if (poolStats.idleCount > poolStats.totalCount * 0.5) {
        recommendations.push("Consider reducing connection pool size - many idle connections");
      }

      recommendations.push("Monitor connection pool metrics regularly for optimal sizing");

      return {
        status: 'analyzed',
        recommendations
      };
    } catch (error: any) {
      return {
        status: 'failed',
        recommendations: ["Failed to analyze connection pool - check pool configuration"]
      };
    }
  }
}

export const createPostgreSQLOptimizer = (pool: Pool) => new PostgreSQLOptimizer(pool);