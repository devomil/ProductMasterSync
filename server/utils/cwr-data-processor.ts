import { db } from "../db";
import { products, categories, productSuppliers } from "@shared/schema";
import { eq, and, isNull } from "drizzle-orm";

/**
 * Process authentic CWR category data into hierarchical structure
 */
export async function processCWRCategories(categoryName: string): Promise<number | null> {
  if (!categoryName || categoryName.trim() === '') {
    return null;
  }

  console.log('Processing CWR category:', categoryName);
  
  // CWR uses format like "Paddlesports | Safety,Marine Safety | Accessories"
  // Split by comma to get multiple category paths
  const categoryPaths = categoryName.split(',').map(path => path.trim());
  
  let finalCategoryId = null;
  
  // Process each category path
  for (const categoryPath of categoryPaths) {
    const parts = categoryPath.split('|').map(part => part.trim());
    let parentId: number | null = null;
    let currentLevel = 0;
    let fullPath = '';
    
    // Create hierarchical categories
    for (const part of parts) {
      if (!part) continue;
      
      fullPath = fullPath ? `${fullPath} | ${part}` : part;
      
      // Check if category exists
      const existingQuery = parentId 
        ? and(eq(categories.name, part), eq(categories.parentId, parentId))
        : and(eq(categories.name, part), isNull(categories.parentId));
      
      const existing = await db.select().from(categories).where(existingQuery);
      
      if (existing.length > 0) {
        parentId = existing[0].id;
      } else {
        // Create new category
        const [newCategory] = await db.insert(categories).values({
          name: part,
          code: generateCategoryCode(part),
          parentId: parentId,
          level: currentLevel,
          path: fullPath,
          attributes: {
            autoGenerated: true,
            level: currentLevel,
            fullPath: fullPath,
            source: 'cwr-sftp'
          }
        }).returning();
        
        parentId = newCategory.id;
        console.log(`âœ… Created category: ${fullPath} (ID: ${parentId})`);
      }
      
      currentLevel++;
    }
    
    // Use the last created/found category as the final one
    if (parentId) {
      finalCategoryId = parentId;
    }
  }
  
  return finalCategoryId;
}

/**
 * Process authentic CWR image URLs
 */
export function processCWRImages(record: any): string[] {
  const images: string[] = [];
  
  // CWR provides multiple image URLs
  if (record['Image (1000x1000) Url'] && record['Image (1000x1000) Url'].trim() !== '') {
    images.push(record['Image (1000x1000) Url'].trim());
  }
  
  if (record['Image (300x300) Url'] && record['Image (300x300) Url'].trim() !== '') {
    images.push(record['Image (300x300) Url'].trim());
  }
  
  // Additional images
  if (record['Image Additional (1000x1000) Urls'] && record['Image Additional (1000x1000) Urls'].trim() !== '') {
    const additionalImages = record['Image Additional (1000x1000) Urls'].split(',')
      .map((url: string) => url.trim())
      .filter((url: string) => url !== '');
    images.push(...additionalImages);
  }
  
  return images;
}

/**
 * Clean HTML descriptions from CWR data
 */
export function processCWRDescription(description: string): string {
  if (!description) return '';
  
  // Remove HTML tags but preserve basic formatting
  return description
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .replace(/&nbsp;/g, ' ') // Replace non-breaking spaces
    .replace(/&amp;/g, '&') // Replace HTML entities
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/\s+/g, ' ') // Normalize whitespace
    .trim();
}

/**
 * Generate category code from name
 */
function generateCategoryCode(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9\s&]/g, '')
    .replace(/\s+/g, '-')
    .replace(/&/g, 'and')
    .substring(0, 50);
}

/**
 * Transform authentic CWR record to product format
 */
export async function transformCWRRecord(record: any, supplierId: number): Promise<any> {
  console.log('Transforming CWR record:', record['CWR Part Number']);
  
  // Process categories
  const categoryId = await processCWRCategories(record['Category Name']);
  
  // Process images
  const images = processCWRImages(record);
  
  // Clean description
  const description = processCWRDescription(record['Full Description'] || record['Title'] || '');
  
  return {
    // Required fields
    name: record['Title'] || record['Uppercase Title'] || `Product ${record['CWR Part Number']}`,
    sku: `EDC${String(Math.floor(Math.random() * 900000) + 100000)}`, // Generate EDC code
    
    // Optional fields with authentic CWR data
    description: description,
    manufacturerPartNumber: record['Manufacturer Part Number'] || null,
    upc: record['UPC Code'] || null,
    categoryId: categoryId,
    manufacturerId: null, // Will be populated separately
    
    // Pricing
    price: parseFloat(record['List Price']) || null,
    cost: parseFloat(record['Your Cost']) || null,
    
    // Inventory
    stockQuantity: parseInt(record['Quantity Available to Ship (Combined)']) || 0,
    
    // Product details
    weight: parseFloat(record['Shipping Weight']) || null,
    dimensions: record['Box Length'] && record['Box Width'] && record['Box Height'] 
      ? `${record['Box Length']} x ${record['Box Width']} x ${record['Box Height']}`
      : null,
    
    // Special flags
    isRemanufactured: record['Remanufactured'] === '1',
    isCloseout: record['Closeout'] === '1',
    isOnSale: record['Sale'] === '1',
    hasRebate: record['Rebate'] === '1',
    hasFreeShipping: record['Free Shipping'] === '1',
    
    // Images - store as JSON array
    images: images.length > 0 ? images : null,
    primaryImage: images.length > 0 ? images[0] : null,
    
    // Metadata
    attributes: {
      cwrPartNumber: record['CWR Part Number'],
      brand: record['Manufacturer Name'],
      countryOfOrigin: record['Country Of Origin'],
      harmonizationCode: record['Harmonization Code'],
      googleMerchantCategory: record['Google Merchant Category'],
      exportable: record['Exportable'] === '1',
      hazardousMaterials: record['Hazardous Materials'] === '1',
      prop65Warning: record['Prop 65'] === '1',
      returnable: record['Returnable'] === '1',
      marketplaceAllowed: record['3rd Party Marketplaces'] === 'Allowed'
    },
    
    status: 'active',
    createdAt: new Date(),
    updatedAt: new Date()
  };
}